# CS-300-Module-Eight-Journal
What was the problem you were solving in the projects for this course?
The problem I was solving In project one for this course involved expanding pseudocode to address the needs of the Computer Science department at ABCU, focusing on two main requirements: printing a list of Computer Science courses in alphanumeric order and providing course information along with prerequisites for a given course. The tasks involve designing pseudocode for opening and reading data from a file, creating course objects, implementing a menu system, and sorting and displaying course lists. A crucial aspect is evaluating the runtime and memory efficiency of different data structures (vector, hash table, and tree) to determine the optimal choice for implementing the program, considering factors such as Big O analysis, and the advantages, and disadvantages of each structure. As for project 2, The goal is to create a command-line program in C++ that efficiently manages and interacts with course data. This involves designing code to read course data from a file and store it in a chosen data structure, implementing a user-friendly menu system with options like loading data, printing an alphanumeric list of courses, printing course information, and providing an exit option. The code should also incorporate industry-standard best practices, including error handling, in-line comments, and appropriate naming conventions for enhanced readability and maintainability.
How did you approach the problem? Consider why data structures are important to understand.
Approaching the projects with a structured strategy is crucial to accomplishing the tasks effectively. It's important to carefully review the project requirements, refer back to prior work, draft pseudocode for each data structure, and perform a Big O analysis for runtime efficiency. Evaluating the advantages and disadvantages of each structure aids in making an informed choice. Understanding data structures is pivotal in these projects as they influence algorithm design, memory efficiency, time complexity, and problem-specific solutions. This knowledge empowers optimal decision-making and ensures adaptability to changing project needs, resulting in well-optimized and efficient solutions.
How did you overcome any roadblocks you encountered while going through the activities or project?
To overcome any roadblocks, I often take breaks to refresh my perspective when I've been staring at my screen for an extended period. If this approach doesn't yield results, I utilize online student services, specifically the 24/7 drop-in tutoring, to connect with a tutor who can provide assistance aligned with my needs. Additionally, if further guidance is required, I reach out To my professor for help when neither my tutor nor I can resolve the issue in a given situation.
How has your work on this project expanded your approach to designing software and developing programs?
Engaging in these projects has significantly broadened my approach to software design and program development. Through the process, I've learned to conceptualize projects from a holistic perspective, considering not only the code but also the underlying architecture and user experience.
How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
Engaging in these projects as a junior in college has significantly reshaped the way I approach programming, emphasizing the core principles of crafting code that's maintainable, readable, and adaptable. Throughout this journey, I've witnessed a notable evolution in my programming practices. I've embraced modular design as a way to break down complex tasks into manageable components, fostering a more organized and maintainable codebase. The importance of clear and consistent naming conventions has become evident, enhancing both my own understanding and that of potential collaborators. Documentation, including well-placed comments, has emerged as an essential practice to provide insights into code logic and decision-making. Regularly using version control tools like Git has streamlined collaboration and version management, crucial skills in collaborative development environments. I've also realized the power of testing and test-driven development, helping me catch errors early and ensure the quality of my code. The concept of refactoring has become a key strategy for code improvement, enabling me to maintain readability and efficiency over time. The project's evolving nature has taught me to design with adaptability in mind, accommodating changes and updates smoothly. Implementing robust error-handling mechanisms has proven crucial for enhancing program reliability. Engaging in code reviews has exposed me to diverse perspectives and coding practices while adhering to industry standards and has honed my ability to write clean and maintainable code. As a junior in college, this project has not only met its immediate objectives but has also imparted skills that will undoubtedly shape my future programming endeavors.
